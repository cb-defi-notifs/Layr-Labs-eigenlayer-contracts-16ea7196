# Contract specs

## Depositing assets with EigenLayer
Any Ethereum account with ETH, who wants to participate in EigenLayr whether as a self-operator or as a delegator, needs to first interact with [EigenLayerDeposit contract](./EigenLayrDeposit.sol) in order to subject their ETH to additional slashing conditions from EigenLayer. Based on how that account wants to stake ETH with EigenLayer, there are multiple options:
  - **Staking + DeFi + Restaking.** [`depositETHIntoLiquidStaking`](https://github.com/Layr-Labs/eignlayr-contracts/blob/849f755d926961c29584a2cb81a3f88335f51328/src/contracts/core/EigenLayrDeposit.sol#L62) enables re-staking of ETH with EigenLayer while requiring EigenLayer to stake the same ETH into Ethereum consensus layer via one of the liquid staking service. The staker needs to specify the liquid staking services `IERC20 liquidStakeToken` that it wants EigenLayer to use for staking its deposited ETH. `depositETHIntoLiquidStaking` also provides the option of specifying the DeFi investment strategy `IInvestmentStrategy strategy` that EigenLayer would use for investing the staking tokens that would be obtained from staking with the liquid staking services. 
  - **Existing staking with beacon chain + Restaking.**  With beacon chain being in operation since Dec 2020, many accounts have already staked their ETH into the consensus layer of the beacon chain. As described below, EigenLayer provisions two methods for such stakers to restake their already-staked ETH. Both methods require providing a `proof` of having staked ETH into the consensus of beacon chain. To construct this `proof`, the snapshot of which `depositor` has staked what amount of ETH into beacon chain is captured using a merkle tree where the leaf node is given by `keccak256(abi.encodePacked(depositor, amount))`. The merkle root of this tree is then updated into EigenLayer every regular [intervals](https://github.com/Layr-Labs/eignlayr-contracts/blob/bb9a773bde16bc4c7e81d2cd407531784fb75df6/src/contracts/middleware/DataLayr/DataLayrServiceManagerStorage.sol#L102). This is done using [confirmDataStoreWithPOSt](https://github.com/Layr-Labs/eignlayr-contracts/blob/bb9a773bde16bc4c7e81d2cd407531784fb75df6/src/contracts/middleware/DataLayr/DataLayrServiceManager.sol#L327). 
    - [`proveLegacyConsensusLayerDeposit`](https://github.com/Layr-Labs/eignlayr-contracts/blob/f0724479452c9fbb7bb72cd20a86d4f0abe67050/src/contracts/core/EigenLayrDeposit.sol#L137) enables already-staked ETH stakers to restake their staked ETH with EigenLayer by submitting a Merkle proof of being a staker in the beacon chain (as a `calldata`). This is necessary as withdrawals and transfer of withdrawal certificate are not enabled yet in Ethereum.
    - [`proveLegacyConsensusLayerDepositBySignature`](https://github.com/Layr-Labs/eignlayr-contracts/blob/f0724479452c9fbb7bb72cd20a86d4f0abe67050/src/contracts/core/EigenLayrDeposit.sol#L91) enables any third-party (`msg.sender`) to submit a Merkle proof of staking into beacon chain on behalf of an already-staked ETH staker `depositor`. This requires `msg.sender` to get signature for a specific message from the `depositor` which is then [verified](https://github.com/Layr-Labs/eignlayr-contracts/blob/92610099e227eca11ea94c025ba8b5eaa9bf6c50/src/contracts/core/EigenLayrDeposit.sol#L157).  
  - **Staking + Restaking.**  [`depositEthIntoConsensusLayer`](https://github.com/Layr-Labs/eignlayr-contracts/blob/7a8a4bfe90e1c0129dc97d95de28056db1b02dbe/src/contracts/core/EigenLayrDeposit.sol#L222) re-staking of ETH with EigenLayer while requiring EigenLayer to stake the same ETH into Ethereum consensus layer via [ETH2 deposit contract](https://etherscan.io/address/0x00000000219ab540356cbb839cbe05303d7705fa). Note that this deposit into ETH2 deposit contract is done using withdrawal credentials of EigenLayer.
 
